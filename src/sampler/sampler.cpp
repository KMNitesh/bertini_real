#include "sampler.hpp"











int main(int argC, char *args[])
{
	
	boost::timer::auto_cpu_timer t;
	
	
	MPI_Init(&argC,&args);
	
	
	boost::filesystem::path inputName, witnessSetName, samplingNamenew;
	
	
	
	
	
	
	
	sampler_configuration sampler_options;
	
	sampler_options.splash_screen();
	sampler_options.parse_commandline(argC, args);
    
	
	
	int MPType, dimension;
	
	boost::filesystem::path directoryName;
	
	get_dir_mptype_dimen( directoryName, MPType, dimension);
	
	
	
	
	
    
	
	witnessSetName = directoryName / "WitnessSet";
	samplingNamenew = directoryName;
	
	
	SolverConfiguration solve_options;
	
	
	//only one will be used.  i don't know how to avoid this duplicity.
	Curve C;
	Surface surf_input;
	
	Decomposition * decom_pointy; // this feels unnecessary
	switch (dimension) {
		case 1:
		{
			C.setup(directoryName);
			decom_pointy = &C;
			
		}
			break;
			
		case 2:
		{
			surf_input.setup(directoryName);
			decom_pointy = &surf_input;
			
		}
			break;
			
		default:
		{
			std::cout << "sampler not capable of sampling anything but dimension 1 or 2.  this is of dim " << dimension << std::endl;
			return 0;
		}
			break;
	}
	
	
	
	
	common_sampler_startup(*decom_pointy,
						   sampler_options,
						   solve_options);// this does nothing so far.  want to abstract it.
	
	
	
	VertexSet V(decom_pointy->num_variables());
	
	V.set_tracker_config(&solve_options.T);
	V.setup_vertices(directoryName / "V.vertex"); //setup V structure from V.vertex
	V.set_same_point_tolerance(1e1*solve_options.T.real_threshold);
	
	
	/////////
	////////
	//////
	////
	//
	//  Generate new sampling data
	//
    

	switch (dimension) {
		case 1:
		{
			if (sampler_options.use_fixed_sampler) {
				C.fixed_sampler(V,
								sampler_options,
								solve_options,
								sampler_options.target_num_samples);
			}
			else{
				if (sampler_options.use_distance_condition) {
					C.adaptive_sampler_distance(V,
												sampler_options,
												solve_options);
				}
				else{
					C.adaptive_sampler_movement(V,
												sampler_options,
												solve_options);
				}
				
			}
			
			
			
			//output
			C.output_sampling_data(directoryName);
			
			V.print(directoryName / "V_samp.vertex");
			
			
		}
			break;
			
		case 2:
		{
			surf_input.fixed_sampler(V,
									 sampler_options,
									 solve_options);
			
			
			surf_input.output_sampling_data(directoryName);
			
			V.print(directoryName / "V_samp.vertex");
			
			
		}
			break;
		default:
			break;
	}
    
	
	
	
    
	//
	//   Done with the main call
	////
	/////
	///////
	////////
	
	
	
	
	
    
    
	
	

	
	clearMP();
	MPI_Finalize();
	
	return 0;
}



void common_sampler_startup(const Decomposition & D,
							sampler_configuration & sampler_options,
							SolverConfiguration & solve_options)
{
	
	parse_input_file(D.input_filename()); // restores all the temp files generated by the parser, to this folder.  i think this can be removed?  but the PPD and tracker config both depend on it...  so maybe not.
	
    
	
	// set up the solver configuration
	get_tracker_config(solve_options, solve_options.T.MPType);
	
	initMP(solve_options.T.Precision);
	
	
	parse_preproc_data("preproc_data", &solve_options.PPD);
    
	
	
	
	
	solve_options.verbose_level(sampler_options.verbose_level());

	
	
	solve_options.T.ratioTol = 0.99999999; // manually assert to be more permissive.  i don't really like this.
	
	
	
	solve_options.use_midpoint_checker = 0;
	solve_options.use_gamma_trick = 0;
    solve_options.robust = true;
	
}






void Curve::adaptive_sampler_movement(VertexSet & V,
										   sampler_configuration & sampler_options,
										   SolverConfiguration & solve_options)
{
    WitnessSet W;
	
	
	parse_input_file(input_filename()); // restores all the temp files generated by the parser, to this folder.
	solve_options.get_PPD();
	
	W.set_input_filename(input_filename());
	W.set_num_variables(num_variables());
	W.set_num_natural_variables(V.num_natural_variables());
    
	W.get_variable_names(num_variables());
	
	
	W.copy_patches(*this);
	
	
	
	
	
	this->randomizer()->setup( W.num_variables()-W.num_patches()-1, solve_options.PPD.num_funcs);
	
	
	
	
	
	adaptive_set_initial_sample_data();
	
	
	V.set_curr_projection(pi(0));
	V.set_curr_input(W.input_filename());
	
	
	
	int	num_vars = this->num_variables();
	
	
	WitnessSet Wnew;
	
	
	vec_mp target_projection;
	init_vec_mp(target_projection,num_vars); target_projection->size = num_vars;
	vec_cp_mp(target_projection,pi(0)); // copy the projection into target_projection
	
	
	vec_mp startpt;
	init_vec_mp(startpt,num_vars); startpt->size = num_vars;
	
	vec_mp estimated_point;
	init_vec_mp(estimated_point,num_vars); estimated_point->size = num_vars-1;
	
	
	vec_mp start_projection;
	init_vec_mp(start_projection,num_vars);  start_projection->size = num_vars;
	vec_cp_mp(start_projection,pi(0)); // grab the projection, copy it into start_projection
	
	
	vec_mp new_point_dehomogenized; init_vec_mp(new_point_dehomogenized, num_vars-1);
	
	comp_mp temp, temp1, target_projection_value;
	init_mp(temp);  init_mp(temp1); init_mp(target_projection_value);
    
	int prev_num_samp, sample_counter;
	std::vector<bool> refine_current, refine_next;
	
	
	
	
	
	
	Vertex temp_vertex;
    
	mpf_t dist_moved; mpf_init(dist_moved);
	int interval_counter;
	int num_refinements;
	std::vector<int> current_indices;
	
	MultilinConfiguration ml_config(solve_options, this->randomizer());
	
	std::cout << "adaptively refining " << num_edges() << " edges by movement method" << std::endl;
	
	
	for (unsigned int ii=0; ii<num_edges(); ii++) // for each of the edges
	{
        
		adaptive_set_initial_refinement_flags(num_refinements,
											  refine_current,
											  current_indices,
											  V,
											  ii, sampler_options);
		
		prev_num_samp = num_samples_on_edge(ii); // grab the number of points from the array of integers
		
		
		
		int pass_number  = 0;//this should be the only place this is reset.
		while (1) // breaking condition is all samples being less than TOL away from each other (in the infty norm sense).
		{
            
			refine_next.resize(prev_num_samp+num_refinements-1);; // allocate refinement flag
            
			std::vector<int> new_indices;
			new_indices.resize(prev_num_samp+num_refinements);
			
			new_indices[0] = current_indices[0];
			sample_counter = 1; // this will be incremented every time we put a point into new_points
								// starts at 1 because already committed one.
								// this should be the only place this counter is reset.
			
			
			if (sampler_options.verbose_level()>=1)
				printf("edge %d, pass %d, %d refinements\n",ii,pass_number,num_refinements);
			
			if (sampler_options.verbose_level()>=2) {
				printf("the current indices:\n");
				for (int jj=0; jj<prev_num_samp; jj++)
					printf("%d ",current_indices[jj]);
				printf("\n\n");
			}
			
			if (sampler_options.verbose_level()>=3) {
				printf("refine_flag:\n");
				for (int jj=0; jj<prev_num_samp-1; jj++) {
                    printf("%s ",refine_current[jj]?"1":"0");
				}
				printf("\n\n");
			}
			
            
			
			num_refinements = 0; // reset this counter.  this should be the only place this is reset
			interval_counter = 0;
			for (int jj=0; jj<prev_num_samp-1; jj++) // for each interval in the previous set
			{
				
				
				
				if (sampler_options.verbose_level()>=2)
					printf("interval %d of %d\n",jj,prev_num_samp-1);
				
				
				
				int startpt_index; int left_index; int right_index;
				
				// set the starting projection and point.
				if (jj==0){// if on the first sample, go the right
					startpt_index = current_indices[1]; //right!
				}
				else{ //go to the left
					startpt_index = current_indices[jj]; // left!
				}
				
				left_index = current_indices[jj];
				right_index = current_indices[jj+1];
				
				
				if (new_indices[sample_counter-1]!=left_index) {
					printf("index mismatch\n");
					br_exit(1);
				}
				
                
				
				if(refine_current[jj]==1) //
				{
                    
					vec_cp_mp(startpt,V[startpt_index].point());
					set_mp(&(start_projection->coord[0]), &(V[startpt_index].projection_values())->coord[0]);
					neg_mp(&(start_projection->coord[0]), &(start_projection->coord[0]));
					
					
					estimate_new_projection_value(target_projection_value,				// the new value
												  estimated_point,
                                                  V[left_index].point(),	//
                                                  V[right_index].point(), // two points input
                                                  pi(0));												// projection (in homogeneous coordinates)
					
					
                    
					neg_mp(&target_projection->coord[0],target_projection_value); // take the opposite :)
					
					
					set_witness_set_mp(W, start_projection,startpt); // set the witness point and linear in the input for the lintolin solver.
					
                    
					if (sampler_options.verbose_level()>=3) {
						print_point_to_screen_matlab(W.point(0),"startpt");
						print_comp_matlab(& W.linear(0)->coord[0],"initial_projection_value");
						print_comp_matlab(target_projection_value,"target_projection_value");
					}
					
					if (sampler_options.verbose_level()>=5)
						W.print_to_screen();
					
					if (sampler_options.verbose_level()>=10) {
						mypause();
					}
					
					
					SolverOutput fillme;
					multilin_solver_master_entry_point(W,         // WitnessSet
                                                       fillme, // the new data is put here!
                                                       &target_projection,
                                                       ml_config,
                                                       solve_options);
					
					fillme.get_noninfinite_w_mult_full(Wnew);
					
					if (Wnew.num_points()==0) {
						std::cout << "tracker did not return any points.  this is essentially an uncaught exception" << std::endl;
						// i have no idea what to do when this happens.
						mypause();
					}
					
					if (sampler_options.verbose_level()>=3)
						print_point_to_screen_matlab(Wnew.point(0), "new_solution");
					
					
					dehomogenize(&new_point_dehomogenized,Wnew.point(0));
					
					
					// check how far away we were from the LEFT interval point
					norm_of_difference(dist_moved,
                                       new_point_dehomogenized, // the current new point
                                       estimated_point);// the estimated point which generated the new point
					
					if ( mpf_cmp(dist_moved, sampler_options.TOL )>0 ){
						refine_next[interval_counter] = true;
						refine_next[interval_counter+1] = true;
						num_refinements+=2;
					}
					else{
                        refine_next[interval_counter] = false;
						refine_next[interval_counter+1] = false;
					}
					
					interval_counter+=2;
					
					
					
					vec_cp_mp(temp_vertex.point(),Wnew.point(0));
					temp_vertex.set_type(CURVE_SAMPLE_POINT);
					
                    if (sampler_options.no_duplicates){
						new_indices[sample_counter] = index_in_vertices_with_add(V, temp_vertex);
					}
					else{
						new_indices[sample_counter] = V.add_vertex(temp_vertex);
					}
					
					sample_counter++;
					
					new_indices[sample_counter] = right_index;
					sample_counter++;
                    
					Wnew.reset();
					
				}
				else {
					if (sampler_options.verbose_level()>=2)
						printf("adding sample %d\n",sample_counter);
					
					refine_next[interval_counter] = 0;
					new_indices[sample_counter] = right_index;
					interval_counter++;
					sample_counter++;
				}
			}
            
			
			if (sampler_options.verbose_level()>=1) // print by default
				printf("\n\n");
			
			if( (num_refinements == 0) || (pass_number >= sampler_options.maximum_num_iterations) ) // if have no need for new samples
			{
				
				if (sampler_options.verbose_level()>=1) // print by default
					printf("breaking\nsample_counter = %d\n",sample_counter);
				
				
				sample_indices_[ii].swap(new_indices);
				break; // BREAKS THE WHILE LOOP
			}
			else{
				
				refine_current = refine_next; // reassign this pointer
				current_indices.swap(new_indices);
                
				prev_num_samp=sample_counter; // update the number of samples
				pass_number++;
			}
            
		}//while loop
		if (sampler_options.verbose_level()>=2) {
			printf("exiting while loop\n");
		}
		printf("\n");
	}  // re: ii (for each edge)
	
	
	
	
	clear_mp(temp); clear_mp(temp1); clear_mp(target_projection_value);
	clear_vec_mp(start_projection); clear_vec_mp(target_projection);
	clear_vec_mp(startpt);
	clear_vec_mp(estimated_point);
    mpf_clear(dist_moved);
	
	
}





void Curve::adaptive_sampler_distance(VertexSet & V,
													sampler_configuration & sampler_options,
													SolverConfiguration & solve_options)
{
    
	
	
	parse_input_file(input_filename()); // restores all the temp files generated by the parser, to this folder.
	solve_options.get_PPD();

	WitnessSet W;
	W.set_input_filename(input_filename()); 
	W.set_num_variables(this->num_variables()); 
	W.set_num_natural_variables(V.num_natural_variables());
	W.get_variable_names(num_variables());
	W.copy_patches(*this);
	
	

	this->randomizer()->setup( W.num_variables()-W.num_patches()-1, solve_options.PPD.num_funcs);
	
	
	
	
	
	adaptive_set_initial_sample_data();
	
	
	V.set_curr_projection(pi(0)); V.set_curr_input(input_filename());
	auto curr_proj_index = V.curr_projection();
	
	
	auto num_vars = num_variables();
	
	
	WitnessSet Wnew;
	
	
	vec_mp target_projection;
	init_vec_mp(target_projection,num_vars); target_projection->size = num_vars;
	vec_cp_mp(target_projection,pi(0)); // copy the projection into target_projection
	
	
	vec_mp startpt;
	init_vec_mp(startpt,num_vars); startpt->size = num_vars;
	
	
	vec_mp start_projection;
	init_vec_mp(start_projection,num_vars);  start_projection->size = num_vars;
	vec_cp_mp(start_projection,pi(0)); // grab the projection, copy it into start_projection
	

	
	
	comp_mp temp, temp1, target_projection_value;
	init_mp(temp);  init_mp(temp1); init_mp(target_projection_value);
    
	int prev_num_samp, sample_counter;
	std::vector<bool> refine_current, refine_next;
	
	
	

	vec_mp dehom_left, dehom_right;
	init_vec_mp(dehom_left,num_vars-1);   dehom_left->size  = num_vars-1;
	init_vec_mp(dehom_right,num_vars-1);  dehom_right->size = num_vars-1;
	
	
	
	Vertex temp_vertex;
    
	mpf_t dist_away; mpf_init(dist_away);
	int interval_counter;
	int num_refinements;
	std::vector<int> current_indices;
	
	MultilinConfiguration ml_config(solve_options, this->randomizer());

	if (sampler_options.verbose_level()>=1)
		std::cout << "sampling " << num_edges() << " edges " << std::endl;
	
	
	for (unsigned int ii=0; ii<num_edges(); ii++) // for each of the edges
	{
        
		adaptive_set_initial_refinement_flags(num_refinements,
                                     refine_current,
                                     current_indices,
                                     V,
                                     ii, sampler_options);
		
		prev_num_samp = num_samples_on_edge(ii); // grab the number of points from the array of integers
		
		
		int pass_number  = 0;//this should be the only place this is reset.
		while((num_refinements>0) && (pass_number < sampler_options.maximum_num_iterations)) // breaking condition is all samples being less than TOL away from each other (in the infty norm sense).
		{
            
			refine_next.resize(prev_num_samp+num_refinements-1); // allocate refinement flag
            
			std::vector<int> new_indices;
			new_indices.resize(prev_num_samp+num_refinements);
			
			new_indices[0] = current_indices[0];
			sample_counter = 1; // this will be incremented every time we put a point into new_points
								// starts at 1 because already committed one.
								// this should be the only place this counter is reset.
			
			if (sampler_options.verbose_level()>=1)
				printf("edge %d, pass %d, %d refinements\n",ii,pass_number,num_refinements);
			
			if (sampler_options.verbose_level()>=2) {
				printf("the current indices:\n");
				for (int jj=0; jj<prev_num_samp; jj++)
					printf("%d ",current_indices[jj]);
				printf("\n\n");
			}
			
			if (sampler_options.verbose_level()>=3) {
				printf("refine_flag:\n");
				for (int jj=0; jj<prev_num_samp-1; jj++) {
                    printf("%s ",refine_current[jj]?"1":"0");
				}
				printf("\n\n");
			}
			
            
			
			num_refinements = 0; // reset this counter.  this should be the only place this is reset
			interval_counter = 0;
			for(int jj=0; jj<prev_num_samp-1; jj++) // for each interval in the previous set
			{
				
				
				
				if (sampler_options.verbose_level()>=2)
					printf("interval %d of %d\n",jj,prev_num_samp-1);
				
				
				
				int startpt_index;
				// set the starting projection and point.
				if (jj==0) // if on the first sample, go the right
					startpt_index = current_indices[1]; //right!
				else //go to the left
					startpt_index = current_indices[jj]; // left!
				
				
				auto left_index = current_indices[jj];
				auto right_index = current_indices[jj+1];
				

				if (refine_current[jj])
				{
                    
					vec_cp_mp(startpt,V[startpt_index].point());
					set_mp(&(start_projection->coord[0]), &(V[startpt_index].projection_values())->coord[curr_proj_index]);
					neg_mp(&(start_projection->coord[0]), &(start_projection->coord[0]));
					
					
					estimate_new_projection_value(target_projection_value,				// the new value
                                                  V[left_index].point(),	//
                                                  V[right_index].point(), // two points input
                                                  pi(0));												// projection (in homogeneous coordinates)
					
					
                    
					neg_mp(&target_projection->coord[0],target_projection_value); // take the opposite :)
					
					
					set_witness_set_mp(W, start_projection, startpt); // set the witness point and linear in the input for the lintolin solver.
					
                    
					if (sampler_options.verbose_level()>=3) {
						print_point_to_screen_matlab(W.point(0),"startpt");
						print_comp_matlab(& (W.linear(0))->coord[0],"initial_projection_value");
						print_comp_matlab(target_projection_value,"target_projection_value");
					}
					
					if (sampler_options.verbose_level()>=5)
						W.print_to_screen();
					
					if (sampler_options.verbose_level()>=10) {
						mypause();
					}
					
					
					SolverOutput fillme;
					multilin_solver_master_entry_point(W,         // WitnessSet
                                                       fillme, // the new data is put here!
                                                       &target_projection,
                                                       ml_config,
                                                       solve_options);
					
					fillme.get_noninfinite_w_mult_full(Wnew);
					
					if (Wnew.num_points()==0) {
						std::cout << "tracker did not return any points." << std::endl;
						continue;
					}
					
					if (sampler_options.verbose_level()>=3)
						print_point_to_screen_matlab(Wnew.point(0), "new_solution");
					
					
					
					dehomogenize(&dehom_left,Wnew.point(0),num_vars);
					dehomogenize(&dehom_right,V[left_index].point(),num_vars);
					dehom_right->size = num_vars-1;
					dehom_left->size = num_vars-1;
					
					// check how far away we were from the LEFT interval point
					norm_of_difference(dist_away,
									   dehom_left, // the current new point
                                       dehom_right);// jj is left, jj+1 is right
					
					if ( mpf_cmp(dist_away, sampler_options.TOL )>0 ){
						refine_next[interval_counter] = true;
						num_refinements++;
					}
					else{
                        refine_next[interval_counter] = false;
					}
					interval_counter++;
					
					
					dehomogenize(&dehom_right,V[right_index].point(),num_vars);
					dehom_right->size = num_vars-1;
					
					// check how far away we were from the RIGHT interval point
					norm_of_difference(dist_away,
                                       dehom_left, // the current new point
                                       dehom_right);
					
					if (mpf_cmp(dist_away, sampler_options.TOL ) > 0){
						refine_next[interval_counter] = 1;
						num_refinements++;
					}
					else{
						refine_next[interval_counter] = 0;
					}
					interval_counter++;
					
					
					vec_cp_mp(temp_vertex.point(),Wnew.point(0));
					temp_vertex.set_type(CURVE_SAMPLE_POINT);
					
                    if (sampler_options.no_duplicates){
						new_indices[sample_counter] = index_in_vertices_with_add(V, temp_vertex);
					}
					else{
						new_indices[sample_counter] = V.add_vertex(temp_vertex);
					}
					
					sample_counter++;
					
					new_indices[sample_counter] = right_index;
					sample_counter++;
                    
					Wnew.reset();
					
				}
				else {
					if (sampler_options.verbose_level()>=2)
						printf("adding sample %d\n",sample_counter);
					
					refine_next[interval_counter] = false;
					new_indices[sample_counter] = right_index;
					interval_counter++;
					sample_counter++;
				}
			}
            
			refine_current = refine_next; // reassign this pointer
			current_indices.swap(new_indices);
            
			prev_num_samp=sample_counter; // update the number of samples
			pass_number++;
            
		}//while loop

		sample_indices_[ii].swap(current_indices);

		if (sampler_options.verbose_level()>=2) {
			printf("done refining edge\n");
		}

	}  // re: ii (for each edge)
	
	
	
	
    
	
	clear_mp(temp); clear_mp(temp1); clear_mp(target_projection_value);
	clear_vec_mp(start_projection); clear_vec_mp(target_projection);
	clear_vec_mp(dehom_right); clear_vec_mp(dehom_left);
	clear_vec_mp(startpt);
    mpf_clear(dist_away);
	
	
}




void Curve::fixed_sampler(VertexSet & V,
									  sampler_configuration & sampler_options,
									  SolverConfiguration & solve_options,
									  int target_num_samples)
{
	
	WitnessSet W;
	
	
	parse_input_file(input_filename()); // restores all the temp files generated by the parser, to this folder.
	
	solve_options.get_PPD();
	
	W.set_input_filename(input_filename());
	W.set_num_variables(num_variables());
	W.set_num_natural_variables(V.num_natural_variables());
    

	W.copy_patches(*this);
	
	
	
	

	this->randomizer()->setup(W.num_variables()-W.num_patches()-1, solve_options.PPD.num_funcs);
	
	
	
	
	
	fixed_set_initial_sample_data(target_num_samples);
	
	V.set_curr_projection(pi(0));
	V.set_curr_input(W.input_filename());
	
	

	
	
	
	//where we will move to
	vec_mp target_projection; init_vec_mp2(target_projection,1,1024); target_projection->size = 1;
	vec_cp_mp(target_projection,pi(0)); // copy the projection into target_projection
	
	if (target_projection->size < W.num_variables()) {
		increase_size_vec_mp(target_projection,W.num_variables()); target_projection->size = W.num_variables();
		for (int ii=W.num_natural_variables(); ii<W.num_variables(); ii++) {
			set_zero_mp(&target_projection->coord[ii]);
		}
	}
	
	W.add_linear(target_projection); // grab copy the (possibly increased) projection into start_projection
	

	
	comp_mp temp, temp1, target_projection_value;
	init_mp2(temp,1024);  init_mp2(temp1,1024); init_mp2(target_projection_value,1024);
    
	
	
	Vertex temp_vertex;
    WitnessSet Wnew; // to hold the output


	MultilinConfiguration ml_config(solve_options,this->randomizer());
	

	comp_mp interval_width; init_mp2(interval_width,1024); set_zero_mp(interval_width);
	comp_mp num_intervals;  init_mp2(num_intervals,1024); set_zero_mp(num_intervals);
	

	for (unsigned int ii=0; ii<num_edges(); ii++) // for each of the edges
	{
		if (get_edge(ii).is_degenerate()) {
			continue;
		}
		else{
		}
		
		if (sampler_options.verbose_level() >= 1)
			std::cout << "\tsampling edge " << ii << std::endl;
		
		neg_mp(& (W.linear(0))->coord[0],&(V[get_edge(ii).midpt()].projection_values())->coord[V.curr_projection()]);
		
		W.reset_points();
		W.add_point(V[get_edge(ii).midpt()].point());
		
		
		mpf_set_d(num_intervals->r,double(target_num_samples-1));
		
		sub_mp(interval_width,&(V[get_edge(ii).right()].projection_values())->coord[V.curr_projection()],&(V[get_edge(ii).left()].projection_values())->coord[V.curr_projection()]);
		
		div_mp(interval_width,interval_width,num_intervals);
		
		set_mp(target_projection_value,&(V[get_edge(ii).left()].projection_values())->coord[V.curr_projection()]);
		
		//add once to get us off 0
		add_mp(target_projection_value,target_projection_value,interval_width);
		
		for (int jj=1; jj<target_num_samples-1; jj++) {
			
			
			
			neg_mp(&target_projection->coord[0],target_projection_value); // take the opposite :)
			
			
			
			if (sampler_options.verbose_level()>=3) {
				print_point_to_screen_matlab(W.point(0),"startpt");
				print_comp_matlab(&W.linear(0)->coord[0],"initial_projection_value");
				print_comp_matlab(target_projection_value,"target_projection_value");
			}
			
			if (sampler_options.verbose_level()>=5)
				W.print_to_screen();
			
			
			SolverOutput fillme;
			multilin_solver_master_entry_point(W,         // WitnessSet
											   fillme, // the new data is put here!
											   &target_projection,
											   ml_config,
											   solve_options);
			
			fillme.get_noninfinite_w_mult_full(Wnew);
			
			if (Wnew.num_points()==0) {
				std::cout << "curve sampler returned no points!" << std::endl;
				//TODO: ah shit!  this ain't good.  how to deal with it?
			}
			
			vec_cp_mp(temp_vertex.point(),Wnew.point(0));
			temp_vertex.set_type(CURVE_SAMPLE_POINT);
			
			if (sampler_options.no_duplicates){
				sample_indices_[ii][jj] = index_in_vertices_with_add(V, temp_vertex);
			}
			else
			{
				sample_indices_[ii][jj] = V.add_vertex(temp_vertex);
			}
			
			
			Wnew.reset();
			add_mp(target_projection_value,target_projection_value,interval_width); // increment this thingy
			
			
		}
		
		

		
	}  // re: ii (for each edge)
	
	
	
	
	clear_mp(temp); clear_mp(temp1);
	clear_vec_mp(target_projection);
	clear_mp(target_projection_value);
	clear_mp(interval_width);
	clear_mp(num_intervals);
    
}





int  Curve::adaptive_set_initial_sample_data()
{

	sample_indices_.resize(num_edges());
	for (unsigned int ii=0; ii<num_edges(); ii++)
	{
		if (get_edge(ii).is_degenerate())
			sample_indices_[ii].push_back(get_edge(ii).midpt());
		else
		{
			sample_indices_[ii].resize(3);
			
			sample_indices_[ii][0] = get_edge(ii).left();
			sample_indices_[ii][1] = get_edge(ii).midpt();
			sample_indices_[ii][2] = get_edge(ii).right();
		}
	}
	
	return 0;
}


int  Curve::fixed_set_initial_sample_data(int target_num_samples)
{
	
	sample_indices_.resize(num_edges());
	for (unsigned int ii=0; ii<num_edges(); ii++)
	{
		if (get_edge(ii).is_degenerate())
			sample_indices_[ii].push_back(get_edge(ii).midpt());
		else
		{
			sample_indices_[ii].resize(target_num_samples);
			sample_indices_[ii][0] = get_edge(ii).left();
			sample_indices_[ii][target_num_samples-1] = get_edge(ii).right();
		}
	}
	return 0;
}





void Curve::adaptive_set_initial_refinement_flags(int & num_refinements, std::vector<bool> & refine_flags, std::vector<int> & current_indices,
                                  VertexSet &V,
                                  int current_edge, sampler_configuration & sampler_options)
{
	
	num_refinements = 0; // reset to 0
	refine_flags.resize(num_samples_on_edge(current_edge)-1);

	current_indices.resize(num_samples_on_edge(current_edge));

	mpf_t dist_away;  mpf_init(dist_away);
	
	vec_mp dehom1, dehom2;  init_vec_mp(dehom1,num_variables()-1); init_vec_mp(dehom2,num_variables()-1);
	dehom1->size = dehom2->size = num_variables()-1;
	
	current_indices[0] = sample_indices_[current_edge][0];
	for (unsigned int ii=0; ii<num_samples_on_edge(current_edge)-1; ii++) {
		refine_flags[ii] = false;
		
		
		current_indices[ii+1] = sample_index(current_edge,ii+1);
		
		for (int jj=0; jj<num_variables()-1; jj++) {
			div_mp(&dehom1->coord[jj],
                   &(V[sample_index(current_edge,ii)].point())->coord[jj+1],
                   &(V[sample_index(current_edge,ii)].point())->coord[0]);
			
			div_mp(&dehom2->coord[jj],
                   &(V[sample_index(current_edge,ii+1)].point())->coord[jj+1],
                   &(V[sample_index(current_edge,ii+1)].point())->coord[0]);
		}
		
		norm_of_difference(dist_away, dehom1, dehom2); // get the distance between the two adjacent points.
		
		if ( mpf_cmp(dist_away, sampler_options.TOL)>0 ){
			refine_flags[ii] = true;
			num_refinements++;
		}
	}
	
	clear_vec_mp(dehom1); clear_vec_mp(dehom2);
	
	mpf_clear(dist_away);
}





//dehomogenizes, takes the average, computes the projection.
//takes in the full projection \pi, including the homogenizing coordinate.
void estimate_new_projection_value(comp_mp result, vec_mp left, vec_mp right, vec_mp pi){
	int ii;
	
	if (left->size < pi->size) {
		printf("left point too short in estimate new projection value\n");
		deliberate_segfault();
	}
	
	if (right->size < pi->size) {
		printf("left point too short in estimate new projection value\n");
		deliberate_segfault();
	}
    //	print_point_to_screen_matlab(left,"left");
    //	print_point_to_screen_matlab(right,"right");
    //	print_point_to_screen_matlab(pi,"pi");
	
	vec_mp dehom_left, dehom_right;
	init_vec_mp(dehom_left,pi->size-1);   dehom_left->size  = pi->size-1;
	init_vec_mp(dehom_right,pi->size-1);  dehom_right->size = pi->size-1;
	
	dehomogenize(&dehom_left,left,pi->size);
	dehomogenize(&dehom_right,right,pi->size);
	
	
	comp_mp temp, temp2, half; init_mp(temp); init_mp(temp2);  init_mp(half);
	
	mpf_set_d(half->r, 0.5); mpf_set_d(half->i, 0.0);
	
    
	set_zero_mp(result);                                           // result = 0;  initialize
	
	for (ii = 0; ii<pi->size-1; ii++) {
		add_mp(temp,&dehom_left->coord[ii],&dehom_right->coord[ii]); //  a = (x+y)
		mul_mp(temp2, temp, half);                                   //  b = a/2
		mul_mp(temp,&pi->coord[ii+1],temp2);                          //  a = b.pi
		set_mp(temp2,result);                                        //  b = result
		add_mp(result, temp, temp2);                                  //  result = a+b
	}
	// in other words, result += (x+y)/2 \cdot pi


    real_threshold(result,1e-9);

	
	clear_mp(temp); clear_mp(temp2); clear_mp(half);
	clear_vec_mp(dehom_right);clear_vec_mp(dehom_left);
	
	return;
}



//dehomogenizes, takes the average, computes the projection.
//takes in the full projection \pi, including the homogenizing coordinate.
// this version returns the estimated point as well.
void estimate_new_projection_value(comp_mp result, vec_mp estimated_point, vec_mp left, vec_mp right, vec_mp pi){

	
	if (left->size != right->size) {
		printf("attempting to estimate_new_projection_value on vectors of different size\n");
		br_exit(98128);
	}
	
	comp_mp temp;  init_mp(temp);
	
	comp_mp half; init_mp(half);
	mpf_set_str(half->r, "0.5", 10); mpf_set_str(half->i, "0.0", 10);
	
	
	
	vec_mp dehom_left, dehom_right;
	init_vec_mp(dehom_left,left->size-1);   dehom_left->size  = left->size-1;
	init_vec_mp(dehom_right,right->size-1); dehom_right->size = right->size-1;
	
	dehomogenize(&dehom_left,left,pi->size);
	dehomogenize(&dehom_right,right,pi->size);
	
	
	
	vec_add_mp(estimated_point, dehom_left, dehom_right);
	vec_mulcomp_mp(estimated_point, estimated_point, half);
	
	set_zero_mp(result);                                           // result = 0;  initialize
	
	for (int ii = 0; ii<pi->size-1; ii++) {                                 //  b = a/2
		mul_mp(temp,&pi->coord[ii+1],&estimated_point->coord[ii]);                          //  a = b.pi
		add_mp(result, result, temp);                                  //  result = a+b
	}
    
	// in other words, result += (x+y)/2 \cdot pi
    
	
	//  i think this thresholding should be moved to outside this call.
	mpf_t zerothresh; mpf_init(zerothresh);
	mpf_set_d(zerothresh, 1e-9);
	if (mpf_cmp(result->i, zerothresh) < 0){
		mpf_set_str(result->i, "0.0", 10);
	}
	
	mpf_clear(zerothresh);
	
	clear_mp(temp); clear_mp(half);
	
	clear_vec_mp(dehom_right);clear_vec_mp(dehom_left);
	
	return;
}


void  Curve::output_sampling_data(boost::filesystem::path base_path) const
{

	boost::filesystem::path samplingName = base_path / "samp.curvesamp";
	
	std::cout << "wrote curve sampling to " << samplingName << std::endl;
	FILE *OUT = safe_fopen_write(samplingName);
	// output the number of vertices
	fprintf(OUT,"%u\n\n",num_edges());
	for (unsigned int ii=0; ii<num_edges(); ii++) {
		fprintf(OUT,"%u\n",num_samples_on_edge(ii));
		for (unsigned int jj=0; jj<num_samples_on_edge(ii); jj++) {
			fprintf(OUT,"%d ",sample_index(ii,jj));
		}
		fprintf(OUT,"\n\n");
	}
	
	fclose(OUT);
}
















void Surface::fixed_sampler(VertexSet & V,
							sampler_configuration & sampler_options,
							SolverConfiguration & solve_options)
{
	
	FixedSampleCurves(V, sampler_options, solve_options);

	//once you have the fixed samples of the curves, down here is just making the integer triangles.
	for (unsigned int ii=0; ii<num_faces(); ii++) {
		
		if (faces_[ii].is_degenerate() || faces_[ii].is_malformed())
			continue;
		
		std::cout << "Face " << ii << std::endl;
		if (sampler_options.verbose_level()>=1)
			std::cout << faces_[ii];

		FixedSampleFace(ii, V, sampler_options, solve_options);
	} // re: for ii, that is for the faces
	
	return;
}


void Surface::FixedSampleCurves(VertexSet & V,
								sampler_configuration & sampler_options,
								SolverConfiguration & solve_options)
{
	int target_num_samples = sampler_options.target_num_samples; 
	
	std::cout << "critical curve" << std::endl;
	crit_curve().fixed_sampler(V,sampler_options,solve_options,target_num_samples);

	std::cout << "sphere curve" << std::endl;
	sphere_curve().fixed_sampler(V,sampler_options,solve_options,target_num_samples);

	std::cout << "mid slices" << std::endl;
	for (auto ii=mid_slices_iter_begin(); ii!=mid_slices_iter_end(); ii++) {
		ii->fixed_sampler(V,sampler_options,solve_options,target_num_samples);
	}
	
	std::cout << "critical slices" << std::endl;
	for (auto ii=crit_slices_iter_begin(); ii!=crit_slices_iter_end(); ii++) {
		ii->adaptive_sampler_distance(V,sampler_options,solve_options);
	}
	
	if (num_singular_curves()>0) {
		std::cout << "singular curves" << std::endl;
		for (auto iter = singular_curves_iter_begin(); iter!= singular_curves_iter_end(); ++iter) {
			iter->second.fixed_sampler(V,sampler_options,solve_options,target_num_samples);
		}
	}
}


void Surface::FixedSampleFace(int face_index, VertexSet & V, sampler_configuration & sampler_options,
										SolverConfiguration & solve_options)
{
	int target_num_samples = sampler_options.target_num_samples; 

	const Face& curr_face = faces_[face_index];
	
	V.set_curr_projection(pi(0));
	V.set_curr_input(this->input_filename());
	
	
	
	// set up a bunch of temporaries

	vec_mp dehom_left, dehom_right; init_vec_mp(dehom_left,0);  dehom_left->size  = 0; init_vec_mp(dehom_right,0); dehom_right->size = 0;
	vec_mp blank_point;  init_vec_mp2(blank_point, 0,1024);
	
	comp_mp interval_width; init_mp2(interval_width,1024); set_one_mp(interval_width);
	comp_mp num_intervals;  init_mp2(num_intervals,1024); set_zero_mp(num_intervals);
	
	mpf_set_d(num_intervals->r,double(target_num_samples-1));
	div_mp(interval_width,interval_width,num_intervals);
	
	mpf_t dist_away; mpf_init(dist_away);
	comp_mp target_projection_value; init_mp2(target_projection_value,1024);
	
	comp_mp temp, temp2; init_mp2(temp,1024); init_mp2(temp2,1024);
	comp_mp half; init_mp(half);
	mpf_set_d(half->r, 0.5); mpf_set_d(half->i, 0.0);
	


	
	auto slice_ind = curr_face.crit_slice_index();
	
	const Curve & current_midslice = mid_slices_[slice_ind];
	const Curve & left_critslice = crit_slices_[slice_ind];
	const Curve & right_critslice = crit_slices_[slice_ind+1];
	
	
	const Curve* bottom = curve_with_name(curr_face.system_name_bottom());
	const Curve* top = curve_with_name(curr_face.system_name_top());;
	auto num_bottom_vars = bottom->num_variables();
	auto num_top_vars = top->num_variables();
	



	//this is here to get ready to use a single midtrack, followed by many multilins.
	//get ready to use the multilin tracker.
	parse_input_file(this->input_filename()); // restores all the temp files generated by the parser, to this folder.
	solve_options.get_PPD();
	
	this->randomizer()->setup(this->num_variables()-this->num_patches()-2, solve_options.PPD.num_funcs);
	MultilinConfiguration ml_config(solve_options, this->randomizer());





	
	vec_mp * target_multilin_linears = (vec_mp *) br_malloc(2*sizeof(vec_mp));
	init_vec_mp2(target_multilin_linears[0],this->num_variables(),1024); target_multilin_linears[0]->size = this->num_variables();
	init_vec_mp2(target_multilin_linears[1],this->num_variables(),1024); target_multilin_linears[1]->size = this->num_variables();
	
	vec_cp_mp(target_multilin_linears[0],pi(0));
	vec_cp_mp(target_multilin_linears[1],pi(1));








	WitnessSet W_multilin;
	W_multilin.set_num_variables(this->num_variables());
	W_multilin.set_num_natural_variables(this->num_variables());
	W_multilin.add_point(blank_point);
	W_multilin.add_linear(pi(0)); W_multilin.add_linear(pi(1));
	W_multilin.add_patch(this->patch(0));








	MidpointConfiguration md_config;
	md_config.setup(*this, solve_options);

	// get the system names
	md_config.system_name_mid = this->input_filename().filename().string();
	md_config.system_name_top = curr_face.system_name_top();
	md_config.system_name_bottom = curr_face.system_name_bottom();
	
	
	// make u, v target values.
	set_mp(md_config.crit_val_left,   &(V[ left_critslice.get_edge(0).midpt() ].projection_values())->coord[0]);
	set_mp(md_config.crit_val_right,  &(V[ right_critslice.get_edge(0).midpt() ].projection_values())->coord[0]);









	
	
	WitnessSet W_midtrack;
	W_midtrack.add_point(blank_point);
	
	//copy in the start point as three points concatenated.
	W_midtrack.set_num_variables(this->num_variables() + num_bottom_vars + num_top_vars);
	W_midtrack.set_num_natural_variables(this->num_variables());
	change_size_vec_mp(W_midtrack.point(0), W_midtrack.num_variables());
	W_midtrack.point(0)->size = W_midtrack.num_variables(); // destructive resize
	
	
	// mid
	int var_counter = 0;
	for (int kk=0; kk<this->num_variables(); kk++) {
		set_mp(&W_midtrack.point(0)->coord[kk], &(V[curr_face.midpt()].point())->coord[kk]);
		var_counter++;
	}
	
	int mid_edge = current_midslice.edge_w_midpt(curr_face.midpt());
	// bottom
	int offset = var_counter;
	for (int kk=0; kk<num_bottom_vars; kk++) {
		set_mp(& W_midtrack.point(0)->coord[kk+offset], &(V[current_midslice.get_edge(mid_edge).left()].point())->coord[kk]); // y0
		var_counter++;
	}
	
	// top
	offset = var_counter;
	for (int kk=0; kk<num_top_vars; kk++) {
		set_mp(& W_midtrack.point(0)->coord[kk+offset], &(V[current_midslice.get_edge(mid_edge).right()].point())->coord[kk]); // y2
		var_counter++;
	}
	
	//copy in the patches appropriate for the systems we will be tracking on.
	W_midtrack.copy_patches(*this);
	W_midtrack.copy_patches(*bottom);
	W_midtrack.copy_patches(*top);
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//we need to sample the ribs
	std::vector< std::vector<int> > ribs;
	ribs.resize(target_num_samples);
	
	
	
	// populate the ribs for the left and right edges, which were generated prior in curve sampling methods.
	for (unsigned int jj=0; jj<curr_face.num_left(); jj++) {
		int left_edge_index = curr_face.left_edge(jj);
		
		for (unsigned int kk = 0; kk< left_critslice.num_samples_on_edge(left_edge_index); kk++) {
			if (jj>0 && kk==0)
				if (left_critslice.sample_index(left_edge_index,kk)==ribs[0].back())
					continue;

			ribs[0].push_back(left_critslice.sample_index(left_edge_index,kk));
		}
	}
	
	for (unsigned int jj=0; jj<curr_face.num_right(); jj++) {
		int right_edge_index = curr_face.right_edge(jj);
		for (unsigned int kk = 0; kk< right_critslice.num_samples_on_edge(right_edge_index); kk++) {
			if (jj>0 && kk==0)
				if (right_critslice.sample_index(right_edge_index,kk)==ribs[target_num_samples-1].back())
					continue;
			
			ribs[target_num_samples-1].push_back(right_critslice.sample_index(right_edge_index,kk));
		}
	}
	
	
	
	
	if (sampler_options.verbose_level()>=1) {
		std::cout << "left rib, from left curve edges:\n";
		for (unsigned int jj=0; jj<ribs[0].size(); jj++) {
			std::cout << ribs[0][jj] << " ";
		}
		std::cout << std::endl;

		std::cout << "right rib, from right curve edges:\n";
		for (unsigned int jj=0; jj<ribs[target_num_samples-1].size(); jj++) {
			std::cout << ribs[target_num_samples-1][jj] << " ";
		}
		std::cout << std::endl;
	}
	
	
	
	
	Vertex temp_vertex;
	

	
	
	//initialize to 0
	set_zero_mp(md_config.u_target); // start at the left
	
	for (int jj=1; jj<target_num_samples-1; jj++) {
		if (sampler_options.verbose_level()>=1)
			std::cout << "sampling rib " << jj << std::endl;

		add_mp(md_config.u_target,md_config.u_target,interval_width);
		set_mp(md_config.v_target,half); // start on the bottom one
		
		bool success_indicator_total = true;



		int curr_bottom_index;
		int curr_top_index;

		try {
			std::cout << bottom << " " << top << '\n';
			curr_bottom_index = bottom->sample_index(curr_face.bottom_edge(),jj);
			curr_top_index = top->sample_index(curr_face.top_edge(),jj);			
		} 
		catch (std::logic_error& e) {
			std::cout << "not completing sampling this face.  reason:" << std::endl << e.what() << std::endl;
			success_indicator_total = false;
			continue;
		}
		
		
		
		
		
		
		SolverOutput fillme;
		int success_indicator = midpoint_solver_master_entry_point(W_midtrack, // carries with it the start points, and the linears.
																   fillme, // new data goes in here
																   md_config,
															   solve_options);

		int startpt_index;
		if (success_indicator!=SUCCESSFUL) {
			std::cout << color::red() << "midpoint solver unsuccesful at generating first point on rib" << color::console_default() << std::endl;
			success_indicator_total = false;
			continue;
		}
		else {
			WitnessSet W_new;
			fillme.get_noninfinite_w_mult_full(W_new);
			if (W_new.num_points()==0) {
				std::cout << color::red() << "midpoint tracker did not return any noninfinite points" << color::console_default() << std::endl;
				continue;
			}
			else{
				
				temp_vertex.set_type(SURFACE_SAMPLE_POINT);
				temp_vertex.set_point(W_new.point(0));
				startpt_index = V.add_vertex(temp_vertex);

				// need to set the values of the projections in the linears -- they are not unit-scaled as is the midpoint tracker.

				// copy in the start point for the multilin method, as the terminal point from the previous call.
				vec_cp_mp(W_multilin.point(0),V[startpt_index].point());
				W_multilin.point(0)->size = this->num_variables();
				neg_mp(&W_multilin.linear(0)->coord[0],&(V[startpt_index].projection_values())->coord[0]);
				neg_mp(&W_multilin.linear(1)->coord[0],&(V[startpt_index].projection_values())->coord[1]);
				
				real_threshold(&W_multilin.linear(0)->coord[0],(V.T())->real_threshold);
				real_threshold(&W_multilin.linear(1)->coord[0],(V.T())->real_threshold);

				neg_mp(&target_multilin_linears[0]->coord[0],&(V[startpt_index].projection_values())->coord[0]);

				real_threshold(&target_multilin_linears[0]->coord[0],(V.T())->real_threshold);								
				// projection value 1 will be set later, when contructing the rib.
			}
		}
		
		
		
		std::vector<int> refined_rib(2);
		refined_rib[0] = curr_bottom_index;
		refined_rib[1] = curr_top_index;
		
		
		std::vector<bool> refine_flags(1, true);
		bool need_refinement = true;
		unsigned pass_number = 0;
		while ( need_refinement && (pass_number < sampler_options.maximum_num_iterations) )
		{
			assert( (refine_flags.size() == refined_rib.size()-1) && "refinement flags must be one less than num entries on rib");
			
			std::vector<int> temp_rib;
			std::vector<bool> refine_flags_next;
			need_refinement = false; // reset to no, in case don't need.  will set to true if point too far apart
			
			for (auto& asdf : refined_rib)
				std::cout << asdf << std::endl;
			std::cout << "\n\n";
			for (unsigned rr=0; rr<refine_flags.size(); ++rr) {
				temp_rib.push_back(refined_rib[rr]);
				if (refine_flags[rr]) {
					estimate_new_projection_value(target_projection_value,		// the new value
												  V[refined_rib[rr]].point(),	//
												  V[refined_rib[rr+1]].point(), // two points input
												  pi(1));

					neg_mp(&target_multilin_linears[1]->coord[0],target_projection_value);
					
					if (sampler_options.verbose_level()>=1)
					{
						std::cout << "refining rib, tracking from\n";
						print_point_to_screen_matlab(W_multilin.point(0),"startpt");

						print_point_to_screen_matlab(W_multilin.linear(0),"start_linear0");
						print_point_to_screen_matlab(W_multilin.linear(1),"start_linear1");

						print_point_to_screen_matlab(target_multilin_linears[0],"target_linear0");
						print_point_to_screen_matlab(target_multilin_linears[1],"target_linear1");

						print_comp_matlab(&V[refined_rib[rr]].projection_values()->coord[1],"left proj val");
						print_comp_matlab(&V[refined_rib[rr+1]].projection_values()->coord[1],"right proj val");
					}

					SolverOutput track_result;
					success_indicator = multilin_solver_master_entry_point(W_multilin,         // WitnessSet
																		   track_result, // the new data is put here!
																		   target_multilin_linears,
																		   ml_config,
																		   solve_options);
					
					WitnessSet W_new;
					track_result.get_noninfinite_w_mult_full(W_new);
					

					if (W_new.num_points()==0) {
						std::cout << color::red() << "multilin tracker did not return any noninfinite points :(" << color::console_default() << std::endl;
						success_indicator_total = false;
						need_refinement = false; // bail out of the refinement loop...
						break;
					}

					
					dehomogenize(&dehom_right,W_new.point(0));
					print_point_to_screen_matlab(dehom_right,"solution");
					if (!checkForReal_mp(dehom_right, (V.T())->real_threshold))
					{
						mypause();
						refine_flags_next.push_back(false);
						continue;
						
					}


					temp_vertex.set_point(W_new.point(0));
					temp_vertex.set_type(SURFACE_SAMPLE_POINT);
					temp_rib.push_back(V.add_vertex(temp_vertex));

					dehomogenize(&dehom_left,V[refined_rib[rr]].point());
					norm_of_difference(dist_away,
									   dehom_left, // the current new point
									   dehom_right);
					
					
					refine_flags_next.push_back(mpf_cmp(dist_away, sampler_options.TOL)>0);
					if (refine_flags_next.back())
						need_refinement = true;
					
					
					dehomogenize(&dehom_left,V[refined_rib[rr+1]].point());
					
					norm_of_difference(dist_away,
									   dehom_left, // the current new point
									   dehom_right);
					
					
					refine_flags_next.push_back(mpf_cmp(dist_away, sampler_options.TOL)>0);
					if (refine_flags_next.back())
						need_refinement = true;
					
					
				}
				else
				{
					refine_flags_next.push_back(false);
				}
				
			}
			temp_rib.push_back(refined_rib.back());
			swap(temp_rib,refined_rib);
			swap(refine_flags_next,refine_flags);

			++pass_number;
		} // re: while
		
		swap(ribs[jj], refined_rib);
		
		
		if (!success_indicator_total) {
			std::cout << color::red() << "generating rib was unsuccesful" << color::console_default() << std::endl;
			continue;
		}
		
	}
	
	//check the ribs.
	for (auto& r : ribs)
	{
		for (int zz=0; zz<int(r.size())-1; zz++) {
			if (mpf_cmp((V[r[zz]].projection_values())->coord[1].r, (V[r[zz+1]].projection_values())->coord[1].r) > 0) {
				std::cout << "out of order, cuz these are off:" << std::endl;
				print_comp_matlab((V[r[zz]].projection_values())->coord,"l");
				print_comp_matlab((V[r[zz+1]].projection_values())->coord,"r");
			}
		}
	}

	StitchRibs(ribs,V);

	
	clear_vec_mp(blank_point);
	clear_mp(target_projection_value);
	mpf_clear(dist_away);
	clear_mp(temp); clear_mp(temp2); clear_mp(interval_width); clear_mp(num_intervals);
	
	clear_vec_mp(target_multilin_linears[0]); clear_vec_mp(target_multilin_linears[1]); free(target_multilin_linears);
	
	clear_vec_mp(dehom_right); clear_vec_mp(dehom_left);
}


void Surface::StitchRibs(std::vector<std::vector<int> > const& ribs, VertexSet & V)
{
	std::vector< Triangle > current_samples;
	for (auto r = ribs.begin(); r!=ribs.end()-1; r++) {
		
		if (r->size()==0 || (r+1)->size()==0) {
			std::cout << "empty rib!" << std::endl;
			continue;
		}
		triangulate_two_ribs_by_angle_optimization(*r, *(r+1), V, (V.T())->real_threshold, current_samples);
	}
	
	samples_.push_back(current_samples); 
}



void triangulate_two_ribs_by_angle_optimization(const std::vector< int > & rib1, const std::vector< int > & rib2,
											  VertexSet & V, double real_thresh,
											  std::vector< Triangle> & current_samples)
{
#ifdef functionentry_output
	std::cout << "triangulate_by_distance_binning" << std::endl;
#endif
	
	
	bool bail_out = false;
	
	if (rib1.size()==0) {
		std::cout << "rib1 had 0 size!" << std::endl;
		bail_out = true;
	}
	if (rib2.size()==0) {
		std::cout << "rib2 had 0 size!" << std::endl;
		bail_out = true;
	}
	
	if (rib1.size()==1 && rib2.size()==1) {
		std::cout << "both ribs have size 1!" << std::endl;
		bail_out = true;
	}
	
	if (bail_out) {
		return;
	}
	
	
	int num_vars = V.num_natural_variables();
	
	unsigned int num_vectors_needed = 9;
	vec_mp * bulk_vectors = (vec_mp *) br_malloc(num_vectors_needed* sizeof(vec_mp));
	
	for (unsigned int ii=0; ii<num_vectors_needed; ii++) {
		init_vec_mp(bulk_vectors[ii],num_vars);  bulk_vectors[ii]->size = num_vars;
		
	}
	
	vec_mp *A = &bulk_vectors[0], *B = &bulk_vectors[1], *C = &bulk_vectors[2], *D = &bulk_vectors[3];


	vec_mp *AB = &bulk_vectors[4];
	vec_mp *AC = &bulk_vectors[5];
	vec_mp *BC = &bulk_vectors[6];
	vec_mp *DA = &bulk_vectors[7];
	vec_mp *DC = &bulk_vectors[8];

	
	
	// seed the advancing loop.
	dehomogenize(B, V[rib1[0]].point(), num_vars);
	(*B)->size = num_vars-1;
	real_threshold(*B,real_thresh);
	dehomogenize(D, V[rib2[0]].point(), num_vars);
	(*D)->size = num_vars-1;
	real_threshold(*D,real_thresh);
	
	
	comp_mp cos_angle_CAB, cos_angle_BCA, cos_angle_ABC;
	init_mp(cos_angle_CAB); init_mp(cos_angle_BCA); init_mp(cos_angle_ABC);
	
	comp_mp cos_angle_DCA, cos_angle_ADC, cos_angle_CAD;
	init_mp(cos_angle_DCA); init_mp(cos_angle_ADC); init_mp(cos_angle_CAD);
	
	
	comp_mp length_AB, length_AC, length_BC, length_DA, length_DC;
	init_mp(length_AB); init_mp(length_AC); init_mp(length_BC); init_mp(length_DA); init_mp(length_DC);
	
	comp_mp dot_CAB, dot_BCA, dot_ABC;
	init_mp(dot_CAB); init_mp(dot_BCA); init_mp(dot_ABC);
	
	comp_mp dot_DCA, dot_ADC, dot_CAD;
	init_mp(dot_DCA); init_mp(dot_ADC); init_mp(dot_CAD);
	
	comp_mp temp;  init_mp(temp);
	comp_d temp_d;
	
	unsigned int curr_index_rib1 = 0, curr_index_rib2 = 0;
	bool moved_1 = true, moved_2 = true;  //this is an intial condition to get them both set properly.  all subsequent iterations have only one as moved==true, and the other is always false.
	while (curr_index_rib1 < rib1.size()-1 // neither rib size is 0, so this -1 is ok, won't underflow
		   &&
		   curr_index_rib2 < rib2.size()-1)
	{

#ifdef debug_compile
		int a =rib1[curr_index_rib1];
		int b =rib1[curr_index_rib1+1];
		int c =rib2[curr_index_rib2];
		int d =rib2[curr_index_rib2+1];
		
		std::cout << rib1[curr_index_rib1] << " " << rib1[curr_index_rib1+1] << std::endl;
		std::cout << rib2[curr_index_rib2] << " " << rib2[curr_index_rib2+1] << std::endl;
#endif
		
		if (moved_1) {
			vec_mp * temp_vec = A; // swap
			A = B;
			B = temp_vec;
			dehomogenize(B, V[rib1[curr_index_rib1+1]].point(), num_vars);
			(*B)->size = num_vars-1;
			real_threshold(*B,real_thresh);

			
			vec_sub_mp(*AB, *B,*A);
			
			
			
			twoNormVec_mp(*AB, length_AB);
		}
							   
		if (moved_2){ // moved_smaller
			vec_mp * temp_vec = C; // swap
			C = D;
			D = temp_vec;
			dehomogenize(D, V[rib2[curr_index_rib2+1]].point(), num_vars);
			(*D)->size = num_vars-1;
			
			real_threshold(*D,real_thresh);
			
			vec_sub_mp(*DC, *C,*D);
			twoNormVec_mp(*DC, length_DC);
		}
		
		
		
//		A           --->           B
//		  ***********************
//		  *- <--              *
//		  * -  --           *
//		  *  -   --       *    --
//		| *   -         *   ---
//		| *    -      *  <--
//		| *     -   *
//		\/*      -*
//		  *     * -
//		  *   *    -
//		  * *       -
//		  *-----------
//		C    <--       D
		
		
		
//        AC, BC, DA,
		
		vec_sub_mp(*AC, *C,*A);
		vec_sub_mp(*BC, *C,*B);
		vec_sub_mp(*DA, *A,*D);
		
		
#ifdef debug_compile
		print_point_to_screen_matlab(*A,"A");
		print_point_to_screen_matlab(*B,"B");
		print_point_to_screen_matlab(*C,"C");
		print_point_to_screen_matlab(*D,"D");
		
		print_point_to_screen_matlab(*AB,"AB");
		print_point_to_screen_matlab(*AC,"AC");
		print_point_to_screen_matlab(*BC,"BC");
		print_point_to_screen_matlab(*DA,"DA");
		print_point_to_screen_matlab(*DC,"DC");
#endif
		
		
		// now have the 5 vectors for the test computed.  (5 because the two triangles share a common leg)
		
		dot_product_mp(dot_CAB, *AC, *AB);
		
		dot_product_mp(dot_BCA, *AC, *BC);
		
		dot_product_mp(dot_ABC, *AB, *BC);
		neg_mp(dot_ABC,dot_ABC);
		
		dot_product_mp(dot_DCA, *DC, *AC);
		
		dot_product_mp(dot_ADC, *DA, *DC);
		
		
		dot_product_mp(dot_CAD, *DA, *AC);
		neg_mp(dot_CAD,dot_CAD);
		
		twoNormVec_mp(*AC, length_AC);
		twoNormVec_mp(*BC, length_BC);
		twoNormVec_mp(*DA, length_DA);
		
		
		double thresh = 3;
		int advance = 0;
		bool aspect_ok_rib1 = true, aspect_ok_rib2 = true;
		
		div_mp(temp,length_BC,length_AB);
		mp_to_d(temp_d, temp);
//		double aspect11 = temp_d->r;
		if ( temp_d->r  > thresh) {
			aspect_ok_rib1 = false;
		}
		div_mp(temp,length_BC,length_AC);
		mp_to_d(temp_d, temp);
//		double aspect12 = temp_d->r;
		if ( temp_d->r  > thresh) {
			aspect_ok_rib1 = false;
		}
//
		
		
		div_mp(temp,length_DA,length_DC);
		mp_to_d(temp_d, temp);
//		double aspect21 = temp_d->r;
		if (temp_d->r > thresh) {
			aspect_ok_rib2 = false;
		}
		div_mp(temp,length_DA,length_AC);
		mp_to_d(temp_d, temp);
//		double aspect22 = temp_d->r;
		if (temp_d->r > thresh) {
			aspect_ok_rib2 = false;
		}

		
		
		
		
		
		// the below lines computes the sum of the squares of the differences of the absolute values of the cosines of two of the angles in one of the triangles.
		
		//CAB
		double total_error_rib1 = compute_square_of_difference_from_sixtydegrees(temp, length_AC, length_AB, dot_CAB);
#ifdef debug_compile
		print_comp_matlab(dot_CAB,"CAB");
		std::cout << c << " " << a << " " << b << " " << total_error_rib1 << std::endl;
#endif
		
		
		//BCA
		double angle_BCA = compute_square_of_difference_from_sixtydegrees(temp, length_BC, length_AC, dot_BCA);
#ifdef debug_compile
		print_comp_matlab(dot_BCA,"BCA");
		std::cout << b << " " << c << " " << a << " " << angle_BCA << std::endl;
#endif
		total_error_rib1 += angle_BCA;
		
		//ABC
		double angle_ABC = compute_square_of_difference_from_sixtydegrees(temp, length_BC, length_AB, dot_ABC);
		total_error_rib1 += angle_ABC;
#ifdef debug_compile
		print_comp_matlab(dot_ABC,"ABC");
		std::cout << a << " " << b << " " << c << " " << angle_ABC << std::endl;
#endif
		
		
		
		
		
		
		//DCA
		double total_error_rib2 = compute_square_of_difference_from_sixtydegrees(temp, length_DC, length_AC, dot_DCA);
#ifdef debug_compile
		print_comp_matlab(dot_DCA,"DCA");
		std::cout << d << " " << c << " " << a << " " << total_error_rib2 << std::endl;
#endif
		
		//ADC
		
		double angle_ADC = compute_square_of_difference_from_sixtydegrees(temp, length_DA, length_DC, dot_ADC);
		
		total_error_rib2+= angle_ADC;
#ifdef debug_compile
		print_comp_matlab(dot_ADC,"ADC");
		std::cout << a << " " << d << " " << c << " " << angle_ADC << std::endl;
#endif
		//CAD
		double angle_CAD = compute_square_of_difference_from_sixtydegrees(temp, length_AC, length_DA, dot_CAD);
		total_error_rib2 += angle_CAD;
		
#ifdef debug_compile
		print_comp_matlab(dot_CAD,"CAD");
		std::cout << c << " " << a << " " << d << " " << angle_CAD << std::endl;
#endif
		
		
		
		
		
		if ((total_error_rib1>0.25) && (total_error_rib2>0.25)){
			// both triangles more or less equilateral, or both are bad
			if ( mpf_cmp(length_DA->r,length_BC->r)<0)
				advance = 2;
			else
				advance = 1;
		}
		else{
			if (total_error_rib1 < total_error_rib2) {
				advance = 1;
			}
			else
				advance = 2;
		}
		
		
//		if(!aspect_ok_rib1 && aspect_ok_rib2) {
//			advance = 2;
//		}
//		else if(!aspect_ok_rib2 && aspect_ok_rib1) {
//			advance = 1;
//		}
//		else if ( (!aspect_ok_rib2 && !aspect_ok_rib1) )
//		{
//			
//			
//			
//				
//			
//		}
//		else
//		{
//			
//			
//			if (total_error_rib1 < total_error_rib2) {
//				advance = 1;
//			}
//			else{
//				advance = 2;
//			}
//		}
		
		
		
		
		if (advance==1) { // if the 1 Triangle is more equilateral than the 2 Triangle.
			current_samples.push_back(
									  Triangle(// Triangle A B C
											   rib1[curr_index_rib1], //A
											   rib1[curr_index_rib1+1], //B
											   rib2[curr_index_rib2]) //C
									  );
			moved_1 = true;  curr_index_rib1++;
			moved_2 = false;
			
		}
		else
		{
			current_samples.push_back(
									  Triangle(// Triangle C A D
											   rib2[curr_index_rib2], //C
											   rib1[curr_index_rib1], //A
											   rib2[curr_index_rib2+1]) //D
									  );
			moved_1 = false;
			moved_2 = true; curr_index_rib2++;
		}
		
	} // re: while loop.
	
	
	
	// now down here, we have triangulated until one of the ribs is on its last point, so there is no more testing that can be done.  you simply have to connect the rest into triangles.
	
	const std::vector< int > *exhausted_rib, *rib_still_going;
	unsigned int index_still_going, terminal_index;
	bool flip;
	
	if (curr_index_rib1==rib1.size()-1) {
		exhausted_rib = &rib1;
		rib_still_going = &rib2;
		index_still_going = curr_index_rib2;
		terminal_index = curr_index_rib1;
		flip = false;
	}
	else
	{
		exhausted_rib = &rib2;
		rib_still_going = &rib1;
		index_still_going = curr_index_rib1;
		terminal_index = curr_index_rib2;
		flip = true;
	}
	
	
	for (; index_still_going < rib_still_going->size()-1; index_still_going++) { // initializer deliberately empty
		
		long long v1, v2, v3;
		if (flip) {
			v1 = rib_still_going->at(index_still_going);
			v2 = rib_still_going->at(index_still_going+1);
		}
		else
		{
			v1 = rib_still_going->at(index_still_going+1);
			v2 = rib_still_going->at(index_still_going);
		}
		v3 = exhausted_rib->at(terminal_index);
		
		current_samples.push_back( Triangle(v1,v2,v3) );
	}
	
	
	
	
	clear_mp(cos_angle_CAB); clear_mp(cos_angle_BCA); clear_mp(cos_angle_ABC);
	clear_mp(cos_angle_DCA); clear_mp(cos_angle_ADC); clear_mp(cos_angle_CAD);
	
	
	clear_mp(length_AB); clear_mp(length_AC); clear_mp(length_BC); clear_mp(length_DA); clear_mp(length_DC);
	clear_mp(dot_CAB); clear_mp(dot_BCA); clear_mp(dot_ABC);
	clear_mp(dot_DCA); clear_mp(dot_ADC); clear_mp(dot_CAD);
	
	clear_mp(temp);
	// clean up at the end.  i wish scope was deletion!
	
	for (unsigned int ii=0; ii<num_vectors_needed; ii++) {
		clear_vec_mp(bulk_vectors[ii]);
	}
	free(bulk_vectors);
	
	
	
	return;
}





double compute_square_of_difference_from_sixtydegrees(comp_mp temp, comp_mp length1, comp_mp length2, comp_mp dot_prod)
{
	comp_d cos;
	
	mul_mp(temp, length1, length2);
	div_mp(temp, dot_prod, temp);
	mp_to_d(cos, temp);
	double error = fabs(cos->r - 0.5);
	
	
//	double angle = acos(cos->r);
//	double pi_over_three = acos(-1)/3;
//	double error = fabs(angle-pi_over_three);

	
//	div_mp(temp, length1,length2)
//	mp_to_d(cos,temp);
//	double error2 = fabs(cos->r - 1);
//	
//	div_mp(temp, length2,length1)
//	mp_to_d(cos,temp);
//	double error3 = fabs(cos->r - 1);
//	
//	double error = error1 + error2 + error3;
	
	return error*error;//*error*error
}








void  Surface::output_sampling_data(boost::filesystem::path base_path) const
{
	
	boost::filesystem::path samplingName = base_path / "samp.surfsamp";
	
	std::cout << "writing surface sampling to " << samplingName << std::endl;
	
	std::ofstream fout(samplingName.string());
	fout << samples_.size() << std::endl << std::endl;
	for (int ii=0; ii<int(samples_.size()); ii++) {
		
		fout << samples_[ii].size() << std::endl;
		
		for (int jj=0; jj<int(samples_[ii].size()); jj++) {
			fout << samples_[ii][jj] << std::endl;
		}
		fout << std::endl;
	}
	
	fout << std::endl;
	fout.close();
	
	
	
	crit_curve_.output_sampling_data(base_path / "curve_crit");
	

	sphere_curve_.output_sampling_data(base_path / "curve_sphere");
	
	
	boost::filesystem::path curve_location = base_path / "curve";
	
	std::stringstream converter;
	
	for (unsigned int ii=0; ii<mid_slices_.size(); ii++) {
		boost::filesystem::path specific_loc = curve_location;
		
		converter << ii;
		specific_loc += "_midslice_";
		specific_loc += converter.str();
		converter.clear(); converter.str("");
		
		
		mid_slices_[ii].output_sampling_data(specific_loc);
	}
	
	for (unsigned int ii=0; ii<crit_slices_.size(); ii++) {
		boost::filesystem::path specific_loc = curve_location;
		
		converter << ii;
		specific_loc += "_critslice_";
		specific_loc += converter.str();
		converter.clear(); converter.str("");
		
		crit_slices_[ii].output_sampling_data(specific_loc);
	}
	
	
	curve_location += "_singular_mult_";
	if (num_singular_curves()>0) {
		
		
		for (auto iter = singular_curves_.begin(); iter!= singular_curves_.end(); ++iter) {
			boost::filesystem::path specific_loc = curve_location;
			converter << iter->first.multiplicity() << "_" << iter->first.index();
			
			specific_loc += converter.str();
			converter.clear(); converter.str("");
			
			iter->second.output_sampling_data(specific_loc);
		}
	}
	
}










void set_witness_set_mp(WitnessSet & W, vec_mp new_linear, vec_mp new_point)
{
	
	W.reset_points();
	W.add_point(new_point);
	
	W.reset_linears();
	W.add_linear(new_linear);
	
//	
//	W->num_points=1;
//	W->pts_mp=(point_mp *)br_malloc(sizeof(point_mp)); // apparently you can only pass in a single point to copy in.
//	
//	//initialize the memory
//	init_point_mp(W->pts_mp[0],num_vars); W->pts_mp[0]->size = num_vars;
//	point_cp_mp(W->pts_mp[0],pts);
//	
//	
//	W->num_linears = 1;
//	W->L_mp = (vec_mp *)br_malloc(sizeof(vec_mp));
//	init_vec_mp(W->L_mp[0],num_vars); W->L_mp[0]->size = num_vars;
//	vec_cp_mp(W->L_mp[0],new_linear);
	
}








int get_dir_mptype_dimen(boost::filesystem::path & Dir_Name, int & MPType, int & dimension){
    
	std::string tempstr;
	std::ifstream fin("Dir_Name");
	fin >> tempstr;
	fin >> MPType;
	fin >> dimension;
	
	Dir_Name = tempstr;
	Dir_Name = Dir_Name.filename();
	return MPType;
}




















